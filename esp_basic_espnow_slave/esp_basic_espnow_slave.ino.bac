
// This program include just basic/standard functions:
// use this for test

extern "C" {
#include <user_interface.h> // for sleep mode
}

#include <ESP8266WiFi.h>

#include <NTP.h>
#include <MyOTA.h>
#include <MyLib.h>
#include <MyCockpit.h>

CheckInterval CI(1000 * 5); // interval for DebugOut log

ADC_MODE(ADC_VCC); // for use of getVcc. ADC pin must be open

int espMode;

void setup() {
  Serial.begin(115200);
  Serial.println("");
  Serial.println("start ESP......................");
  //DebugOut.setToFile();
  Serial.setDebugOutput(false);
  //WiFi.printDiag(DebugOut);

  // json config
  if ( ESP_rtcUserMemoryRead().startsWith("{") && jsonConfig.loadRtcMem() ) {
    ESP_rtcUserMemoryWrite("");
  } else {
    jsonConfig.load();
  }
  JsonObject &conf = jsonConfig.obj();
  // set default value
  if ( !conf["recvDataBufSize"] ) {
    conf["recvDataBufSize"] = 20 * 40;
    jsonConfig.save();
  }

  // decide AP/STA mode
  if ( conf["connectNet"] == 1 ) {
    espMode = 0;
  } else if ( conf["wakeup"] > 0 ) {
    espMode = 1;
  } else if ( conf["mode"] == String("EspNow") || conf["mode"] == String("EspNowDSleep") ) {
    espMode = 1;
  } else {
    espMode = 0;
  }

  if ( espMode == 0 ) {
    DebugOut.println("setup for STA mode...");
    wifi_set_sleep_type(LIGHT_SLEEP_T); // default=modem
    WiFiConnect();
    printSystemInfo();
    ntp_begin(2390);
  } else {
    DebugOut.println("seutp for espnow (AP) mode...");
    // restore time
    if ( conf["time"] ) {
      unsigned long t = conf["time"];
      setTime(t);
    }
    // setup
    WiFi.mode(WIFI_AP); // OK
    //  WiFi.mode(WIFI_STA); // NG. cannot receive msg on both STA and AP MAC
    //  WiFi.mode(WIFI_AP_STA); // NG. receive AP MAC only, error if STA connected
    //IPAddress local_IP(192,168,1,22);
    //IPAddress gateway(192,168,1,1);
    //IPAddress subnet(255,255,255,0);
    //DebugOut.println(WiFi.softAPConfig(local_IP, gateway, subnet) ? "Ready" : "Failed!");
    WiFi.softAP("foobar", "12345678", 1, 0);
    setupEspNow(NULL, NULL, slave_recv_cb);
  }

  // common setup
  setupMyOTA();
  addHtmlMyCockpit(String("Sketch: ") + THIS_SKETCH + "<BR><BR>");
  addMyCockpit("/interval", 1, []() {
    String n = server.arg(0);
    CI.set(n.toInt());
    server.send(200, "text/plain", n + ", ok");
  });
  addMyCockpit("/recvDataBufSize", 1, []() {
    String n = server.arg(0);
    jsonConfig.obj()["recvDataBufSize"] = n.toInt();
    jsonConfig.save();
    server.send(200, "text/plain", n + ", ok");
  });
  addMyCockpit("/toEspNow", 0, []() {
    jsonConfig.obj()["mode"] = "EspNow";
    jsonConfig.save();
    server.send(200, "text/plain", "ok");
  });
  addMyCockpit("/fromEspNow", 0, []() {
    jsonConfig.obj()["mode"] = "STA";
    jsonConfig.save();
    server.send(200, "text/plain", "ok");
  });
  addMyCockpit("/connectNet", 0, []() {
    jsonConfig.obj()["connectNet"] = 1;
    jsonConfig.save();
    server.send(200, "text/plain", "ok");
  });
  addMyCockpit("/wakeupController", 1, []() {
    String no = server.arg(0);
    jsonConfig.obj()["wakeup"] = no.toInt();
    jsonConfig.save();
    server.send(200, "text/plain", "ok");
  });
  setupMyCockpit();
  DebugOut.println(getDateTimeNow() + ": setup end.");
}


void loop() {
  JsonObject &conf = jsonConfig.obj();

  if ( conf["test"] == 1 ) {
    conf["test"] = 0;
    jsonConfig.save();

    Serial.println(ESP_rtcUserMemoryRead());
    ESP_rtcUserMemoryWrite("aaabbbcccdddeee");
    Serial.println(ESP_rtcUserMemoryRead());
    delay(3000);
  }

  // post process for call backs
  DebugOut.print(espNowBuffer.log);
  espNowBuffer.log = "";

  if ( espMode == 1 ) { // ESP-Now mode
    // send wakeup
    if ( conf["wakeup"] > 0 ) {
      DebugOut.println(getDateTimeNow() + ": send wakeup req...");
      int id = conf["wakeup"];
      if ( id >= numMacAddr ) {
        DebugOut.println("Error: illegal mac address id specified");
        conf["wakeup"] = 0; // complete
      } else {
        uint8_t message[] = ESPNOW_REQ_WAKEUP; // wakeup req
        uint8_t *mac = macAddrSTA[id];
        if ( sendEspNow(mac, message, 4) ) { // success
          conf["wakeup"] = 0; // complete
        } else { // fail
          conf["wakeup"] = -id; // pending for polling // TODO: pending for only one device
        }
      }
    }

    // re-action for request
    for (int i = 0; i < espNowBuffer.recvReqBufferMax(); i++ ) { // for each request in buffer
      uint8_t type = espNowBuffer.recvReq[i].data[3];
      //DebugOut.println(macAddress2String(espNowBuffer.recvReq[i].mac));
      //DebugOut.println(sprintEspNowData(espNowBuffer.recvReq[i].data,4));
      DebugOut.println(type);
      if ( type == 1 ) { // poll req
        DebugOut.println(getDateTimeNow() + ": " + "poll action...");
        if ( conf["wakeup"] < 0 ) { // pending exists
          int id = conf["wakeup"];
          uint8_t *mac = macAddrSTA[-id];
          if ( macAddress2String(mac) == macAddress2String(espNowBuffer.recvReq[i].mac) ) { // this is pending
            DebugOut.println("send wakeup req...");
            uint8_t message[] = ESPNOW_REQ_WAKEUP;
            if ( sendEspNow(espNowBuffer.recvReq[i].mac, message, 4) ) { // success
              conf["wakeup"] = 0;
            }
          }
        }
      }
    }
    espNowBuffer.recvReqNum = 0; // clear req in buffer

    // action for data reveiced
    for (int i = 0; i < espNowBuffer.recvDataBufferMax(); i++ ) { // for each data packet in buffer
      // get data
      char buf[251]; // max payload + '\0'
      memcpy(buf, espNowBuffer.recvData[i].data, espNowBuffer.recvData[i].len);
      buf[espNowBuffer.recvData[i].len] = '\0';
      // store to file
      fileAppend("/espNowRcvData.txt", getDateTimeNow().c_str());
      fileAppend("/espNowRcvData.txt", ", ");
      fileAppend("/espNowRcvData.txt", buf);
      fileAppend("/espNowRcvData.txt", "\r\n");
    }
    espNowBuffer.recvDataNum = 0; // clear data packet in buffer

    // upload received data file
    long sz = fileSize("/espNowRcvData.txt");
    if ( sz > conf["recvDataBufSize"] ) {
      DebugOut.println(getDateTimeNow() + ": " + "big file size. its time to switch to upload data...");
      conf["connectNet"] = 1;
    }

    // change mode
    if ( conf["connectNet"] == 1 || conf["mode"] != String("EspNow") ) {
      DebugOut.println(getDateTimeNow() + ": " + "switch to STA flow...");
      jsonConfig.save();
      SPIFFS.end(); ESP.restart();
    }

  } else { // STA mode
    // upload data
    if ( conf["connectNet"] == 1 ) { // one shot STA mode
      uploadRecvData();
      DebugOut.println(getDateTimeNow() + ": exit one-shot STA mode...");
      conf["connectNet"] = 0; // reset connectNet
      conf["time"] = now();      // store time
      jsonConfig.save();
      SPIFFS.end(); ESP.restart(); // for return to espnow mode
    }

    // change mode
    if ( conf["wakeup"] > 0 || conf["mode"] == String("EspNow") ) {
      DebugOut.println(getDateTimeNow() + ": switch to esp-now flow...");
      conf["time"] = now();      // store time
      jsonConfig.save();
      SPIFFS.end(); ESP.restart();
    }

    // put log
    if ( CI.check() ) {
      DebugOut.println("sta mode: " + getDateTimeNow() + " VCC: " + ESP.getVcc() / 1024.0);
    }

    loopMyOTA();
  }

  // common
  loopMyCockpit();
  delay(500);
}

// upload recept data to network
bool uploadRecvData() {
  File fs = SPIFFS.open("/espNowRcvData.txt", "r");
  if ( !fs ) {
    DebugOut.println("Error: cannot open file");
    return false;
  }
  bool toomany = false;
  for (int i = 0; fs.available(); i++ ) {
    if ( i > 50 ) {
      toomany = true;
      break;
    }
    String ln = fs.readStringUntil('\r');
    triggerIFTTT("espnow", getDateTimeNow(), ln, "");
  }
  fs.close();
  if ( toomany ) {
    triggerIFTTT("espnow", getDateTimeNow(), "too many data to send.", "");
  }
  fileDelete("/espNowRcvData.txt");
}

